name: AI Pipeline Failure Triage

on:
  workflow_run:
    workflows: ["ML Model CI/CT/CD Pipeline"]
    types:
      - completed

permissions:
  contents: read
  issues: write
  actions: read  # CRITICAL: Needed to read workflow run details

jobs:
  triage-failure:
    name: AI-Powered Failure Analysis
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'failure' }}  # Simplified condition
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get workflow run details
        id: workflow-info
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const runId = context.payload.workflow_run.id;
            const run = await github.rest.actions.getWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: runId
            });
            
            const jobs = await github.rest.actions.listJobsForWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: runId,
              filter: 'latest'
            });
            
            const failedJobs = jobs.data.jobs.filter(job => job.conclusion === 'failure');

            let failureLogs = '';
            if (failedJobs.length > 0) {
              const jobId = failedJobs[0].id;
              try {
                const logs = await github.rest.actions.downloadJobLogsForWorkflowRun({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  job_id: jobId
                });
                failureLogs = logs.data || 'Could not retrieve logs';
              } catch (error) {
                failureLogs = `Error fetching logs: ${error.message}`;
              }
            }

            const failureInfo = {
              workflow_name: run.data.name,
              run_url: run.data.html_url,
              failed_job_name: failedJobs.length > 0 ? failedJobs[0].name : 'Unknown',
              failed_step: failedJobs.length > 0 ? failedJobs[0].steps.find(s => s.conclusion === 'failure')?.name : 'Unknown',
              commit_message: run.data.head_commit.message,
              commit_sha: run.data.head_sha.substring(0, 7),
              branch: run.data.head_branch,
              logs: failureLogs.substring(0, 5000)
            };

            core.setOutput('failure_info', JSON.stringify(failureInfo));
            return failureInfo;

      - name: Download artifacts from failed run
        id: download-artifacts
        uses: actions/github-script@v7
        continue-on-error: true
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const runId = context.payload.workflow_run.id;
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: runId
            });

            const banditArtifact = artifacts.data.artifacts.find(a => a.name === 'bandit-report');
            const trivyArtifact = artifacts.data.artifacts.find(a => a.name === 'trivy-results');

            let artifactInfo = {};
            if (banditArtifact) artifactInfo.bandit_url = banditArtifact.archive_download_url;
            if (trivyArtifact) artifactInfo.trivy_url = trivyArtifact.archive_download_url;

            core.setOutput('artifacts', JSON.stringify(artifactInfo));
            return artifactInfo;

      - name: Analyze failure with Gemini AI
        id: ai-analysis
        run: |
          # Install gcloud SDK
          curl https://sdk.cloud.google.com | bash -s -- --disable-prompts
          source $HOME/google-cloud-sdk/path.bash.inc
          
          # Authenticate
          echo "${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}" | base64 -d > /tmp/gcp-key.json
          gcloud auth activate-service-account --key-file=/tmp/gcp-key.json
          gcloud config set project ${{ secrets.GCP_PROJECT_ID }}
          
          # Get access token
          ACCESS_TOKEN=$(gcloud auth print-access-token)
          
          # Parse failure info
          FAILURE_INFO='${{ steps.workflow-info.outputs.failure_info }}'
          
          # Determine failure type
          FAILED_JOB=$(echo $FAILURE_INFO | jq -r '.failed_job_name')
          
          if [[ "$FAILED_JOB" == *"SAST"* ]] || [[ "$FAILED_JOB" == *"Bandit"* ]]; then
            FAILURE_TYPE="Security Scan (SAST)"
            PROMPT_CONTEXT="You are a DevSecOps security specialist. A SAST security scan failed."
          elif [[ "$FAILED_JOB" == *"train"* ]] || [[ "$FAILED_JOB" == *"Training"* ]]; then
            FAILURE_TYPE="Model Training"
            PROMPT_CONTEXT="You are an ML engineer. Model training or validation failed."
          elif [[ "$FAILED_JOB" == *"test"* ]]; then
            FAILURE_TYPE="Unit Tests"
            PROMPT_CONTEXT="You are a Python testing expert. Unit tests failed."
          elif [[ "$FAILED_JOB" == *"Container"* ]] || [[ "$FAILED_JOB" == *"Trivy"* ]]; then
            FAILURE_TYPE="Container Security Scan"
            PROMPT_CONTEXT="You are a DevSecOps specialist. Container image vulnerability scan failed."
          else
            FAILURE_TYPE="Pipeline Failure"
            PROMPT_CONTEXT="You are a DevOps/MLOps engineer. A CI/CD pipeline step failed."
          fi
          
          # Build prompt
          PROMPT_TEXT="${PROMPT_CONTEXT}\n\n**Pipeline Failure Details:**\n- Workflow: $(echo $FAILURE_INFO | jq -r '.workflow_name')\n- Failed Job: $(echo $FAILURE_INFO | jq -r '.failed_job_name')\n- Failed Step: $(echo $FAILURE_INFO | jq -r '.failed_step')\n- Branch: $(echo $FAILURE_INFO | jq -r '.branch')\n- Commit: $(echo $FAILURE_INFO | jq -r '.commit_sha') - $(echo $FAILURE_INFO | jq -r '.commit_message')\n\n**Logs (excerpt):**\n\`\`\`\n$(echo $FAILURE_INFO | jq -r '.logs')\n\`\`\`\n\n**Your Task:**\nProvide a markdown analysis with:\n1. **Root Cause** (What exactly caused the failure?)\n2. **Risk Assessment** (Is this a blocker?)\n3. **Fix Instructions** (Step-by-step with specific commands/code)\n4. **Prevention** (How to avoid this?)\n\nBe specific and actionable. Keep under 500 words."
          
          # Create JSON payload
          cat > gemini-request.json << EOF
          {
            "contents": [{
              "role": "user",
              "parts": [{
                "text": $(echo "$PROMPT_TEXT" | jq -Rs .)
              }]
            }],
            "generationConfig": {
              "temperature": 0.2,
              "maxOutputTokens": 1024,
              "topP": 0.95
            }
          }
          EOF
          
          # Call Gemini API
          ANALYSIS=$(curl -s -X POST \
            -H "Authorization: Bearer ${ACCESS_TOKEN}" \
            -H "Content-Type: application/json" \
            "https://us-central1-aiplatform.googleapis.com/v1/projects/${{ secrets.GCP_PROJECT_ID }}/locations/us-central1/publishers/google/models/gemini-2.5-flash-lite:generateContent" \
            -d @gemini-request.json | jq -r '.candidates[0].content.parts[0].text // "âŒ Gemini API call failed"')
          
          echo "$ANALYSIS" > triage-report.md
          echo "ANALYSIS<<EOF" >> $GITHUB_OUTPUT
          echo "$ANALYSIS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "FAILURE_TYPE=$FAILURE_TYPE" >> $GITHUB_OUTPUT

      - name: Create GitHub Issue with Triage Report
        uses: actions/github-script@v7
        env:
          ANALYSIS_CONTENT: ${{ steps.ai-analysis.outputs.ANALYSIS }}
          FAILURE_TYPE: ${{ steps.ai-analysis.outputs.FAILURE_TYPE }}
          FAILURE_INFO: ${{ steps.workflow-info.outputs.failure_info }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const analysis = process.env.ANALYSIS_CONTENT;
            const failureType = process.env.FAILURE_TYPE;
            const failureInfo = JSON.parse(process.env.FAILURE_INFO);
            
            let severityLabel = 'pipeline-failure';
            if (failureType.includes('Security')) {
              severityLabel = 'security-issue';
            } else if (failureType.includes('Training')) {
              severityLabel = 'ml-model-issue';
            }
            
            const issueBody = [
              `## ðŸ”´ Pipeline Failure: ${failureInfo.failed_job_name}`,
              '',
              `**Failure Type:** ${failureType}`,
              `**Branch:** \`${failureInfo.branch}\``,
              `**Commit:** ${failureInfo.commit_sha} - ${failureInfo.commit_message}`,
              `**Workflow Run:** ${failureInfo.run_url}`,
              '',
              '---',
              '',
              '## ðŸ¤– AI-Generated Triage Analysis',
              '',
              analysis,
              '',
              '---',
              '',
              '## ðŸ“‹ Quick Actions',
              '',
              '- [ ] Review the AI analysis',
              '- [ ] Apply the suggested fix',
              '- [ ] Test locally before pushing',
              '',
              '---',
              '',
              '<details>',
              '<summary>ðŸ“Š View Full Logs</summary>',
              '',
              '```',
              failureInfo.logs,
              '```',
              '',
              '</details>',
              '',
              '---',
              '',
              '**Triage Engine:** Google Gemini 2.5 Flash Lite',
              `**Auto-generated:** ${new Date().toISOString()}`
            ].join('\n');
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `[PIPELINE FAILURE] ${failureType} - ${failureInfo.commit_sha}`,
              body: issueBody,
              labels: ['pipeline-failure', 'ai-triage', severityLabel]
            });

      - name: Upload triage report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: ai-triage-report
          path: triage-report.md