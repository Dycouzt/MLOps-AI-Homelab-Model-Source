name: AI Pipeline Failure Triage

on:
  workflow_run:
    workflows: ["ML Model CI/CT/CD Pipeline"]
    types:
      - completed

permissions:
  contents: read
  issues: write
  actions: read

jobs:
  triage-failure:
    name: AI-Powered Failure Analysis
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'failure' }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get workflow run details and logs
        id: workflow-info
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const runId = context.payload.workflow_run.id;
            
            // Get workflow run details
            const run = await github.rest.actions.getWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: runId
            });
            
            // Get all jobs for this run
            const jobs = await github.rest.actions.listJobsForWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: runId,
              filter: 'latest'
            });
            
            const failedJobs = jobs.data.jobs.filter(job => job.conclusion === 'failure');
            
            let failureLogs = 'No detailed logs available';
            let failedStepName = 'Unknown';
            let failedStepLogs = '';
            
            if (failedJobs.length > 0) {
              const failedJob = failedJobs[0];
              
              // Find the failed step and extract its output from the job
              const failedStep = failedJob.steps.find(s => s.conclusion === 'failure');
              if (failedStep) {
                failedStepName = failedStep.name;
                
                // Build logs from step information and job annotations
                let logParts = [];
                
                // Add step information
                logParts.push(`Failed Step: ${failedStep.name}`);
                logParts.push(`Step Number: ${failedStep.number}`);
                logParts.push(`Started: ${failedStep.started_at}`);
                logParts.push(`Completed: ${failedStep.completed_at}`);
                logParts.push('---');
                
                // Get annotations (these often contain error messages)
                try {
                  const annotations = await github.rest.checks.listAnnotations({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    check_run_id: failedJob.id
                  });
                  
                  if (annotations.data && annotations.data.length > 0) {
                    logParts.push('ERROR ANNOTATIONS:');
                    annotations.data.forEach(ann => {
                      logParts.push(`[${ann.annotation_level}] ${ann.path}:${ann.start_line}`);
                      logParts.push(ann.message);
                      logParts.push('---');
                    });
                  }
                } catch (e) {
                  logParts.push(`Could not fetch annotations: ${e.message}`);
                }
                
                // Add job conclusion
                logParts.push(`Job Conclusion: ${failedJob.conclusion}`);
                logParts.push(`Job Status: ${failedJob.status}`);
                
                failedStepLogs = logParts.join('\n');
              }
              
              // Build comprehensive log info from available data
              let comprehensiveLogs = [];
              
              comprehensiveLogs.push('=== WORKFLOW FAILURE DETAILS ===');
              comprehensiveLogs.push(`Workflow: ${run.data.name}`);
              comprehensiveLogs.push(`Run URL: ${run.data.html_url}`);
              comprehensiveLogs.push(`Conclusion: ${run.data.conclusion}`);
              comprehensiveLogs.push('');
              comprehensiveLogs.push('=== FAILED JOB DETAILS ===');
              comprehensiveLogs.push(`Job Name: ${failedJob.name}`);
              comprehensiveLogs.push(`Job ID: ${failedJob.id}`);
              comprehensiveLogs.push(`Runner: ${failedJob.runner_name || 'N/A'}`);
              comprehensiveLogs.push('');
              comprehensiveLogs.push('=== FAILED STEP INFORMATION ===');
              comprehensiveLogs.push(failedStepLogs);
              comprehensiveLogs.push('');
              comprehensiveLogs.push('=== ALL STEPS STATUS ===');
              failedJob.steps.forEach(step => {
                comprehensiveLogs.push(`[${step.conclusion || 'RUNNING'}] Step ${step.number}: ${step.name}`);
              });
              
              failureLogs = comprehensiveLogs.join('\n');
              
              // Limit size
              if (failureLogs.length > 6000) {
                failureLogs = failureLogs.substring(0, 6000) + '\n... (truncated)';
              }
            }
            
            const failureInfo = {
              workflow_name: run.data.name,
              run_url: run.data.html_url,
              failed_job_name: failedJobs.length > 0 ? failedJobs[0].name : 'Unknown',
              failed_job_url: failedJobs.length > 0 ? failedJobs[0].html_url : run.data.html_url,
              failed_step: failedStepName,
              commit_message: run.data.head_commit.message,
              commit_sha: run.data.head_sha.substring(0, 7),
              branch: run.data.head_branch,
              logs: failureLogs
            };
            
            core.setOutput('failure_info', JSON.stringify(failureInfo));
            return failureInfo;

      - name: Analyze failure with Gemini AI
        id: ai-analysis
        run: |
          # Install gcloud SDK
          curl https://sdk.cloud.google.com | bash -s -- --disable-prompts
          source $HOME/google-cloud-sdk/path.bash.inc
          
          # Authenticate
          echo "${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}" | base64 -d > /tmp/gcp-key.json
          gcloud auth activate-service-account --key-file=/tmp/gcp-key.json
          gcloud config set project ${{ secrets.GCP_PROJECT_ID }}
          
          # Get access token
          ACCESS_TOKEN=$(gcloud auth print-access-token)
          
          # Parse failure info
          FAILURE_INFO='${{ steps.workflow-info.outputs.failure_info }}'
          
          # Determine failure type
          FAILED_JOB=$(echo $FAILURE_INFO | jq -r '.failed_job_name')
          FAILED_STEP=$(echo $FAILURE_INFO | jq -r '.failed_step')
          
          if [[ "$FAILED_JOB" == *"SAST"* ]] || [[ "$FAILED_JOB" == *"Bandit"* ]]; then
            FAILURE_TYPE="Security Scan (SAST)"
            PROMPT_CONTEXT="You are a DevSecOps security specialist. The SAST scan failed."
          elif [[ "$FAILED_JOB" == *"train"* ]] || [[ "$FAILED_JOB" == *"Training"* ]] || [[ "$FAILED_STEP" == *"Train"* ]]; then
            FAILURE_TYPE="Model Training/Validation"
            PROMPT_CONTEXT="You are an ML engineer. Model training failed. Common causes: import errors, missing dependencies, accuracy below threshold, data issues."
          elif [[ "$FAILED_JOB" == *"test"* ]] || [[ "$FAILED_STEP" == *"test"* ]]; then
            FAILURE_TYPE="Unit Tests"
            PROMPT_CONTEXT="You are a Python expert. Unit tests failed."
          elif [[ "$FAILED_JOB" == *"Container"* ]] || [[ "$FAILED_JOB" == *"Trivy"* ]]; then
            FAILURE_TYPE="Container Security"
            PROMPT_CONTEXT="You are a DevSecOps specialist. Container scan failed."
          elif [[ "$FAILED_STEP" == *"Lint"* ]] || [[ "$FAILED_STEP" == *"flake8"* ]]; then
            FAILURE_TYPE="Code Quality"
            PROMPT_CONTEXT="You are a code quality expert. Linting failed."
          else
            FAILURE_TYPE="Pipeline Failure"
            PROMPT_CONTEXT="You are a DevOps engineer. The pipeline failed."
          fi
          
          # Extract job URL for user to view full logs
          JOB_URL=$(echo $FAILURE_INFO | jq -r '.failed_job_url')
          
          # Build prompt
          PROMPT_TEXT="${PROMPT_CONTEXT}\n\n**Failure Summary:**\n- Job: $(echo $FAILURE_INFO | jq -r '.failed_job_name')\n- Step: $(echo $FAILURE_INFO | jq -r '.failed_step')\n- Commit: $(echo $FAILURE_INFO | jq -r '.commit_sha') - $(echo $FAILURE_INFO | jq -r '.commit_message')\n\n**Available Information:**\n$(echo $FAILURE_INFO | jq -r '.logs')\n\n**Important:** The detailed logs are at: ${JOB_URL}\n\n**Your Task:**\nBased on the failure type (${FAILURE_TYPE}) and available information, provide:\n\n1. **Most Likely Root Cause** - What probably caused this? (e.g., missing import, wrong dependency, syntax error)\n2. **Recommended Fix** - Specific action to take\n3. **How to Verify** - Command to test the fix locally\n4. **Prevention** - How to avoid this\n\nBe concise. If you don't have enough error details, say so and guide the user to check the full logs at the job URL. Keep under 400 words."
          
          # Create JSON payload
          cat > gemini-request.json << EOF
          {
            "contents": [{
              "role": "user",
              "parts": [{
                "text": $(echo "$PROMPT_TEXT" | jq -Rs .)
              }]
            }],
            "generationConfig": {
              "temperature": 0.3,
              "maxOutputTokens": 800,
              "topP": 0.95
            }
          }
          EOF
          
          # Call Gemini API
          ANALYSIS=$(curl -s -X POST \
            -H "Authorization: Bearer ${ACCESS_TOKEN}" \
            -H "Content-Type: application/json" \
            "https://us-central1-aiplatform.googleapis.com/v1/projects/${{ secrets.GCP_PROJECT_ID }}/locations/us-central1/publishers/google/models/gemini-2.5-flash-lite:generateContent" \
            -d @gemini-request.json | jq -r '.candidates[0].content.parts[0].text // "âŒ Gemini API call failed"')
          
          echo "$ANALYSIS" > triage-report.md
          echo "ANALYSIS<<EOF" >> $GITHUB_OUTPUT
          echo "$ANALYSIS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          echo "FAILURE_TYPE=$FAILURE_TYPE" >> $GITHUB_OUTPUT

      - name: Create GitHub Issue with Triage Report
        uses: actions/github-script@v7
        env:
          ANALYSIS_CONTENT: ${{ steps.ai-analysis.outputs.ANALYSIS }}
          FAILURE_TYPE: ${{ steps.ai-analysis.outputs.FAILURE_TYPE }}
          FAILURE_INFO: ${{ steps.workflow-info.outputs.failure_info }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const analysis = process.env.ANALYSIS_CONTENT;
            const failureType = process.env.FAILURE_TYPE;
            const failureInfo = JSON.parse(process.env.FAILURE_INFO);
            
            let severityLabel = 'pipeline-failure';
            if (failureType.includes('Security')) {
              severityLabel = 'security-issue';
            } else if (failureType.includes('Training')) {
              severityLabel = 'ml-model-issue';
            }
            
            const issueBody = [
              `## ðŸ”´ Pipeline Failure: ${failureInfo.failed_job_name}`,
              '',
              `**Failure Type:** ${failureType}`,
              `**Failed Step:** ${failureInfo.failed_step}`,
              `**Branch:** \`${failureInfo.branch}\``,
              `**Commit:** ${failureInfo.commit_sha} - ${failureInfo.commit_message}`,
              '',
              `**ðŸ”— [View Full Logs](${failureInfo.failed_job_url})**`,
              '',
              '---',
              '',
              '## ðŸ¤– AI-Generated Triage',
              '',
              analysis,
              '',
              '---',
              '',
              '## ðŸ“‹ Quick Actions',
              '',
              '- [ ] Review the AI analysis',
              '- [ ] Check the full logs link above for details',
              '- [ ] Apply the suggested fix',
              '- [ ] Test locally',
              '',
              '---',
              '',
              '<details>',
              '<summary>ðŸ“Š Workflow Details</summary>',
              '',
              '```',
              failureInfo.logs,
              '```',
              '',
              '</details>',
              '',
              '---',
              '',
              '**Analysis Engine:** Google Gemini 2.5 Flash Lite  ',
              `**Auto-generated:** ${new Date().toISOString()}`
            ].join('\n');
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `[PIPELINE FAILURE] ${failureType} - ${failureInfo.commit_sha}`,
              body: issueBody,
              labels: ['pipeline-failure', 'ai-triage', severityLabel]
            });

      - name: Upload triage report
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: ai-triage-report
          path: triage-report.md